Event Manager interfaces
========================

Event Dispatching allows developer to inject logic into an application easily.
Many frameworks implement some form of a event dispatching that allows users to
inject functionality with the need to extend classes.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119][].

[RFC 2119]: http://tools.ietf.org/html/rfc2119

## Goal

Having common interfaces for dispatching and handling events, allows developers to create libraries that can interact with many frameworks in a common fashion.

Some examples:

* Security framework that will prevent saving/accessing data when a user doesn't have permission.
* A Common full page caching system
* Logging package to track all actions taken within the application

## Terms

*   **Event** - An action that about to take place (or has taken place).  The event name MUST only contain the characters `A-Z`, `a-z`, `0-9`, `_`, and '.'.
It is RECOMMENDED that words in event names be separated using '.' ex. 'foo.bar.baz.bat'

*   **Listener** - A list of callbacks that are passed the EventInterface and MAY return a result.  Listeners MAY be attached to the EventManager with a priority.  Listeners MUST BE called based on priority.

## Components

There are 2 interfaces needed for dispatching events:

1. An event object which contains all the information about the event.
2. The event dispatcher which holds all the listeners

### EventInterface

The EventInterface defines the methods needed to dispatch an event.  Each event MUST contain a event name in order trigger the listeners. Each event MAY have a 
target which is an object that is the context the event is being triggered for. OPTIONALLY the event can have additional parameters for use within the event.

The event MUST contain a propegation flag that singles the EventManager to stop passing along the event to other listeners.

```php

namespace Psr\EventManager;

/**
 * Representation of an event
 */
interface EventInterface
{
    /**
     * Get event name
     *
     * @return string
     */
    public function getName();

    /**
     * Indicate whether or not to stop propagating this event
     *
     * @param  bool $flag
     */
    public function stopPropagation();

    /**
     * Has this event indicated event propagation should stop?
     *
     * @return bool
     */
    public function isPropagationStopped();
}
```

### EventDispatcherInterfaceInterface

The EventDispatcherInterface holds all the listeners for a particular event.  Since an event can have many listeners that each return a result, the EventDispatcherInterface  MUST return the result from the last listener.

```php

namespace Psr\EventDispatcherInterface;

/**
 * Interface for EventDispatcherInterface
 */
interface EventDispatcherInterface
{
    /**
     * Attaches a listener to an event
     *
     * @param string   $eventName The event to remove a listener from
     * @param callable $callback a callable function
     * @param int      $priority the priority at which the $callback executed
     *
     * @return bool true on success false on failure
     */
    public function addListener($eventName, $callback, $priority = 0);

    /**
     * Removes an event listener from the specified events.
     *
     * @param string   $eventName The event to remove a listener from
     * @param callable $listener  The listener to remove
     *
     * @return void
     */
    public function removeListener($eventName, $listener);

    /**
     * Dispatches an event to all registered listeners.
     *
     * @param EventInterface  $event  The event to pass to the event handlers/listeners.
     *
     * @return EventInterface
     *
     * @api
     */
    public function dispatch(EventInterface $event = null);
}
```
